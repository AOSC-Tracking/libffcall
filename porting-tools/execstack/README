Programs that use hand-written (or otherwise generated) assembly language
source files need to care about the "no executable stack" security feature.

More in detail: The stack VMA of a process may be executable or not.
It is good, for security reasons, if the stack is not executable (because
it makes exploits of many security holes harder). See
<https://en.wikipedia.org/wiki/Executable_space_protection>.

* On some platforms, the stack is always executable.

* On some other platforms, the stack is never executable.

* On some other (ELF) platforms, the stack is not executable by default,
  but it becomes executable if the program or some of its shared
  libraries includes .o files that were assembled from .s files
  without a
    .section .note.GNU-stack,"",@progbits
  line.
  In other words, a .o file may declare the need for an executable stack.
  Most .o files generated by GCC declare that they don't need an executable
  stack.

  Additionally, the GNU assembler (as) has options to influence whether a .o
  file declares the need for an executable stack:
    --execstack             require executable stack for this object
    --noexecstack           don't require executable stack for this object

  And the GNU linker (ld or gold) has similar options to influence whether
  a binary declares the need for an executable stack:
    -z execstack              Mark output as requiring executable stack
    -z noexecstack            Mark output as not requiring executable stack
  GNU gold also has a warning option:
    --warn-execstack          Warn if the stack is executable
    --no-warn-execstack       Do not warn if the stack is executable (default)

  There is also a program, 'execstack', that influences whether a program
  or a shared library declares the need for an executable stack.
  See <https://linux.die.net/man/8/execstack>.

  To inspect whether a .o file, program, or shared library declares the need
  for an executable stack, use either
    $ execstack -q FILE
  or (for a program or shared library only)
    $ readelf --program-headers --wide FILE \
        | sed -n -e 's/^  GNU_STACK .*RW\(.\).*/\1/p' | tr 'E ' 'X-'

Since libffcall is a library, it should not burden its users with the need
to use particular linker options, nor with the need to run 'execstack' on
the program. Therefore libffcall must make sure to not declare the need
for an executable stack.


The files in this directory can be used to determine whether the
GNU-stack note (or, equivalently, a --noexecstack option) is required
for .s files on a given platform.
Source files:
  - main.c        Main program. It tries to execute a "return" instruction
                  on the stack. If it succeeds, it prints "OK". If it fails,
                  it crashes through SIGSEGV.
  - emptyasm.s    An empty assembly language source file.
  - stacknote.s   An assembly language source file that contains the said note.
  - Makefile      It produces five programs:
                    default   --  from main.c
                    emptyasm  --  from main.c + emptyasm.s
                    stacknote --  from main.c + stacknote.s
                    forced-execstack -- from main.c and a --execstack .o
                    forced-noexecstack -- from main.c and a --noexecstack .o


Results:
                                Linux    binutils    default  emptyasm  stacknote  forced-    forced-
                                version  version                                   execstack  noexecstack
--- x86 / x86_64
Linux Ubuntu 32-bit:            4.4.62   2.26.1      crash    OK        crash      OK         crash
Linux Ubuntu 32-bit (x32 ABI):  4.4.62   2.26.1      crash    OK        crash      OK         crash
Linux Ubuntu 64-bit:            4.4.62   2.26.1      crash    OK        crash      OK         crash
Linux CentOS 6 64-bit:          2.6.32   2.20.51.0.2 crash    OK        crash      OK         crash
Linux CentOS 7 64-bit:          3.10.0   2.25.1      crash    OK        crash      OK         crash
FreeBSD 11 32-bit:                       2.17.50     OK       OK        OK         OK         OK
FreeBSD 11 64-bit:                       2.17.50     crash    OK        crash      OK         crash
GNU/kFreeBSD 9 64-bit:                   2.22        OK       OK        OK         OK         OK
NetBSD 7 32-bit:                         2.23.2      crash    crash     crash      crash      crash
NetBSD 7 64-bit:                         2.23.2      crash    crash     crash      crash      crash
OpenBSD 6 32-bit:                        2.17        crash    crash     crash      crash      crash
OpenBSD 6 64-bit:                        2.17        crash    crash     crash      crash      crash
Hurd 32-bit:                             2.27.90     OK       OK        OK         OK         OK
--- mips / mips64
Linux mips 32-bit               3.16.0   2.25        OK       OK        OK         OK         OK
Linux mips64 n32 ABI            3.16.0   2.25        OK       OK        OK         OK         OK
Linux mips64 64 ABI             3.16.0   2.25        OK       OK        OK         OK         OK
--- sparc / sparc64
Linux sparc 32-bit              4.5.0    2.27.90     crash    OK        crash      OK         crash
Linux sparc 64-bit              4.5.0    2.27.90     crash    OK        crash      OK         crash
--- alpha
Linux alpha                     2.6.26   2.18.0      crash    OK        crash      OK         crash
--- arm
Linux armv5                     3.16.0   2.25        OK       OK        OK         OK         OK
Linux armv7                     3.16.0   2.25        crash    OK        crash      OK         crash
--- arm64
Linux arm64                     3.16.0   2.25        crash    crash     crash      OK         crash
--- powerpc / powerpc64
Linux powerpc 32-bit            3.17.2   2.23.2      crash    OK        crash      OK         crash
Linux powerpc 64-bit            3.17.2   2.23.2      crash    crash     crash      crash      crash
Linux powerpc LE ELFv2 64-bit   3.10.0   2.25.1      crash    crash     crash      OK         crash
--- ia64
Linux ia64                      2.6.18   2.17.50.0.6 crash    crash     crash      crash      crash
--- s390 / s390x
Linux s390x 31-bit              3.16.0   2.25        OK       OK        OK         OK         OK
Linux s390x 64-bit              3.16.0   2.25        OK       OK        OK         OK         OK
--- riscv32 / riscv64
Linux riscv32                   4.15.0   2.30        crash    crash     crash      OK         crash
Linux riscv64                   4.16.0   2.30        crash    crash     crash      OK         crash
--- loongarch64
Linux loongarch64               5.15.0+  2.37.50+    crash    OK        crash      OK         crash

Notes:
* The Linux CentOS 6 64-bit result is independent of how the SELinux flags
  allow_execheap, allow_execmem, allow_execstack are set (e.g. through
  system-config-selinux).
* On arm, the syntax is  '%progbits'  instead of  '@progbits'  .
* On Linux mips, the programs 'default' and 'emptyasm' don't have a GNU_STACK
  ELF header. Additionally, the program 'forced-noexecstack' has a GNU_STACK
  ELF header identical to the program 'forced-execstack' - surely a bug!
* On Linux arm64 (starting with binutils 2.24) and
  Linux powerpc64 (starting with binutils 2.18) and
  Linux ia64 (starting with binutils 2.18) and
  Linux riscv32, Linux riscv64,
  an assembly language file without a GNU-stack note does NOT declare the need
  for an executable stack. However, a .o file created with the assembler option
  --execstack does. This is due to the definition
    #define elf_backend_default_execstack 0
  in GNU binutils, for these CPU types.
* FreeBSD 11 has the support for execstack handling in binutils, but on 32-bit
  x86 apparently not in the kernel.
* Hurd has the support for execstack handling in binutils, but not in libc
  (see glibc/sysdeps/mach/hurd/dl-execstack.c).
* On NetBSD and OpenBSD, the programs 'default' and 'emptyasm' don't have a
  GNU_STACK ELF header, whereas the programs 'stacknote', 'forced-noexecstack',
  'forced-execstack' have a GNU_STACK ELF header that declare the need for
  an executable stack. Fortunately, the kernel ignores it all.

Summary:
* The GNU-stack note has an effect only on Linux and FreeBSD kernels.
* On some CPUs (mips, s390), the stack is probably(?) always executable.
* On some other CPUs (ia64), the stack is never executable.
* For the remaining CPUs, it's worth using the GNU-stack note, so as to
  avoid a negative impact on security.


More details about the CPUs on Linux: Look at the definition of
elf_read_implies_exec in linux/arch/$arch.

  linux-4.8.1/include/linux/elf.h:7:#ifndef elf_read_implies_exec
  linux-4.8.1/include/linux/elf.h:11:# define elf_read_implies_exec(ex, have_pt_gnu_stack)        0
This implies that, unless overridden by CPU specific code, the stack is
non-executable, regardless what the PT_GNU_STACK ELF header says.
But this doesn't match the observed behaviour on alpha, sparc, s390. ??

  linux-4.8.1/arch/arm/include/asm/elf.h:105:extern int arm_elf_read_implies_exec(const struct elf32_hdr *, int);
  linux-4.8.1/arch/arm/include/asm/elf.h:106:#define elf_read_implies_exec(ex,stk) arm_elf_read_implies_exec(&(ex), stk)
  linux-4.8.1/arch/arm/kernel/elf.c:83:int arm_elf_read_implies_exec(const struct elf32_hdr *x, int executable_stack)
  linux-4.8.1/arch/arm/kernel/elf.c:91:EXPORT_SYMBOL(arm_elf_read_implies_exec);
On arm, if the CPU architecture is < armv6, the stack is executable.
Other than that, the stack is executable, unless the PT_GNU_STACK ELF header
requests a non-executable stack.

  linux-4.8.1/arch/arm64/include/asm/elf.h:110:#define elf_read_implies_exec(ex,stk)      (stk != EXSTACK_DISABLE_X)
On arm64, the stack is executable, unless the PT_GNU_STACK ELF header
requests a non-executable stack.

  linux-4.8.1/arch/ia64/include/asm/elf.h:204:#define elf_read_implies_exec(ex, executable_stack)                                 \
On ia64, if the ELF flag EF_IA_64_LINUX_EXECUTABLE_STACK is not set,
the the stack is not executable.
Other than that, the stack is executable, unless the PT_GNU_STACK ELF header
requests a non-executable stack.

  linux-4.8.1/arch/mips/include/asm/elf.h:502:#define elf_read_implies_exec(ex, stk) mips_elf_read_implies_exec(&(ex), stk)
  linux-4.8.1/arch/mips/include/asm/elf.h:503:extern int mips_elf_read_implies_exec(void *elf_ex, int exstack);
  linux-4.8.1/arch/mips/kernel/elf.c:333:int mips_elf_read_implies_exec(void *elf_ex, int exstack)
  linux-4.8.1/arch/mips/kernel/elf.c:347:EXPORT_SYMBOL(mips_elf_read_implies_exec);
On mips, if the CPU doesn't have 'rixi', the stack is executable.
Other than that, the stack is executable, unless the PT_GNU_STACK ELF header
requests a non-executable stack.

  linux-4.8.1/arch/powerpc/include/asm/elf.h:103: * An executable for which elf_read_implies_exec() returns TRUE will
  linux-4.8.1/arch/powerpc/include/asm/elf.h:109:# define elf_read_implies_exec(ex, exec_stk) (is_32bit_task() ? \
  linux-4.8.1/arch/powerpc/include/asm/elf.h:112:# define elf_read_implies_exec(ex, exec_stk) (exec_stk == EXSTACK_DEFAULT)
On 32-bit powerpc, the stack is executable, unless the PT_GNU_STACK ELF
header requests an executable stack OR a non-executable stack. (This surely
looks like a bug. But this doesn't match the observed behaviour. ??)
On powerpc64, the stack is a non-executable, regardless what the
PT_GNU_STACK ELF header says. (But this matches only half of the observed
behaviour. ??)

  linux-4.8.1/arch/x86/include/asm/elf.h:271: * An executable for which elf_read_implies_exec() returns TRUE will
  linux-4.8.1/arch/x86/include/asm/elf.h:274:#define elf_read_implies_exec(ex, executable_stack)  \
On i386 and x86_64, the stack is executable, unless the PT_GNU_STACK ELF
header requests a non-executable stack.

Summary:
My tests regarding specific CPUs were incomplete.
It's worth using the GNU-stack note on all CPUs except mips.

